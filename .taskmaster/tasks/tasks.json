{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Fix Auth & Household Context System",
        "description": "Resolve the critical issue where householdId context gets lost when users navigate away from budget setup and returns.",
        "details": "1. Audit the `useUser` hook implementation to identify why householdId becomes undefined on navigation.\n2. Ensure Supabase session persistence across route changes.\n3. Add proper error recovery without requiring page refresh.\n4. Implement debugging/logging for context loss scenarios.\n\nPossible implementation:\n```typescript\n// src/hooks/useUser.ts\nexport function useUser() {\n  const [state, setState] = useState({\n    user: null,\n    householdId: null,\n    loading: true,\n    error: null\n  });\n\n  // Use localStorage as fallback for householdId\n  useEffect(() => {\n    const storedHouseholdId = localStorage.getItem('householdId');\n    \n    // Subscribe to auth state changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        setState(prev => ({ ...prev, loading: true }));\n        \n        if (session) {\n          try {\n            // Get user's household\n            const { data, error } = await supabase\n              .from('household_members')\n              .select('household_id')\n              .eq('user_id', session.user.id)\n              .single();\n            \n            if (error) throw error;\n            \n            // Store householdId in localStorage as backup\n            if (data?.household_id) {\n              localStorage.setItem('householdId', data.household_id);\n            }\n            \n            setState({\n              user: session.user,\n              householdId: data?.household_id || storedHouseholdId,\n              loading: false,\n              error: null\n            });\n          } catch (error) {\n            console.error('Error fetching household:', error);\n            setState({\n              user: session.user,\n              householdId: storedHouseholdId, // Use fallback\n              loading: false,\n              error\n            });\n          }\n        } else {\n          // User is not authenticated\n          localStorage.removeItem('householdId');\n          setState({\n            user: null,\n            householdId: null,\n            loading: false,\n            error: null\n          });\n        }\n      }\n    );\n    \n    // Cleanup subscription\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, []);\n\n  return state;\n}\n```",
        "testStrategy": "1. Unit test the `useUser` hook with mocked Supabase responses.\n2. Integration test for navigation scenarios:\n   - Navigate from budget setup to another page and back\n   - Refresh the page during budget setup\n   - Test with network interruptions\n3. Verify householdId persistence across different navigation patterns.\n4. Test error recovery mechanisms when context is lost.\n5. Verify that users don't need to refresh the page when returning to budget setup.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Optimize Fixed Expenses Step Performance",
        "description": "Improve the performance of the Fixed Expenses step which currently feels 'loady' and laggy compared to the income step.",
        "details": "1. Perform a performance audit to identify bottlenecks:\n   - Compare bundle sizes between StepIncome vs StepFixedExpenses\n   - Check for unnecessary re-renders using React DevTools\n   - Audit database query performance\n   - Review component mounting/unmounting patterns\n\n2. Implement optimizations:\n```typescript\n// Memoize expensive components\nconst FixedExpenseSummaryCard = memo(({ expense, onEdit, onDelete }) => {\n  // Component implementation\n});\n\n// Optimize database queries\nconst loadFixedExpenses = async (householdId: string) => {\n  // Add proper indexes to the database\n  // Use select only needed fields\n  const { data, error } = await supabase\n    .from('fixed_expenses')\n    .select('id, name, amount, frequency_type, frequency_config')\n    .eq('household_id', householdId)\n    .eq('is_active', true)\n    .order('sort_order');\n  return { data, error };\n};\n\n// Implement virtualization for long lists\nimport { useVirtualizer } from '@tanstack/react-virtual';\n\nconst ExpensesList = ({ expenses }) => {\n  const parentRef = useRef();\n  \n  const rowVirtualizer = useVirtualizer({\n    count: expenses.length,\n    getScrollElement: () => parentRef.current,\n    estimateSize: () => 80, // Approximate row height\n  });\n  \n  return (\n    <div ref={parentRef} className=\"h-[500px] overflow-auto\">\n      <div\n        style={{\n          height: `${rowVirtualizer.getTotalSize()}px`,\n          position: 'relative',\n        }}\n      >\n        {rowVirtualizer.getVirtualItems().map((virtualRow) => (\n          <div\n            key={virtualRow.index}\n            style={{\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: '100%',\n              height: `${virtualRow.size}px`,\n              transform: `translateY(${virtualRow.start}px)`,\n            }}\n          >\n            <FixedExpenseSummaryCard \n              expense={expenses[virtualRow.index]}\n              onEdit={() => handleEdit(expenses[virtualRow.index])}\n              onDelete={() => handleDelete(expenses[virtualRow.index])}\n            />\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n```\n\n3. Implement lazy loading for the form component:\n```typescript\nconst FixedExpenseForm = lazy(() => import('./fixed-expense-form'));\n```\n\n4. Optimize state updates to prevent unnecessary re-renders:\n```typescript\nconst handleSave = useCallback(async (expense) => {\n  // Implementation\n}, [dependencies]);\n```",
        "testStrategy": "1. Measure performance before and after optimizations using:\n   - React DevTools Profiler\n   - Lighthouse performance metrics\n   - Custom timing measurements for key operations\n2. Test with large datasets (20+ expenses) to ensure smooth performance\n3. Verify sub-200ms form interactions\n4. Compare bundle sizes before and after optimizations\n5. Test on lower-end devices to ensure performance improvements are universal",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Conduct Performance Audit",
            "description": "Analyze the Fixed Expenses step for performance bottlenecks, including bundle size, unnecessary re-renders, inefficient database queries, and component lifecycle issues.",
            "dependencies": [],
            "details": "Use profiling tools (such as React DevTools Profiler and Chrome DevTools) to measure render times, identify large bundle sizes, track component mount/unmount cycles, and monitor database query performance.\n<info added on 2025-06-20T15:43:36.278Z>\nPerformance audit results: The primary bottleneck identified is the rendering of a potentially long, un-virtualized list of expenses. The ExpenseItem component is rendered in a loop without proper memoization, causing inefficient re-renders of the entire list whenever any state changes. Secondary issues include suboptimal client-side data fetching patterns. The immediate focus should be on implementing memoization for the ExpenseItem components and optimizing the list rendering process to prevent unnecessary re-renders.\n</info added on 2025-06-20T15:43:36.278Z>",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Memoize Expensive Components",
            "description": "Apply memoization techniques to expensive components within the Fixed Expenses step to prevent unnecessary re-renders.",
            "dependencies": [
              1
            ],
            "details": "Use React.memo for functional components and useMemo for expensive calculations or derived data. Ensure that only components with stable props are memoized to maximize effectiveness.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Optimize Database Queries",
            "description": "Refactor and optimize database queries used in the Fixed Expenses step to reduce latency and server load.",
            "dependencies": [
              1
            ],
            "details": "Analyze query execution plans, add appropriate indexes, batch requests where possible, and minimize the number of queries triggered by component updates.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Implement Virtualization for Long Lists",
            "description": "Introduce list virtualization to efficiently render long lists of fixed expenses, reducing DOM node count and improving scroll performance.",
            "dependencies": [
              1
            ],
            "details": "Use libraries like react-window or react-virtualized to render only visible list items, ensuring smooth scrolling and lower memory usage.",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Add Lazy Loading for Form Component",
            "description": "Implement lazy loading for the form component in the Fixed Expenses step to decrease initial bundle size and improve load times.",
            "dependencies": [
              1
            ],
            "details": "Use React.lazy and Suspense to load the form component only when it is needed, leveraging code-splitting and dynamic imports.",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Optimize State Updates to Prevent Unnecessary Re-renders",
            "description": "Refactor state management in the Fixed Expenses step to minimize unnecessary re-renders and improve overall responsiveness.",
            "dependencies": [
              1
            ],
            "details": "Use local state where appropriate, avoid passing unnecessary props, and leverage techniques like useCallback and context selectors to limit component updates.",
            "status": "done"
          }
        ]
      },
      {
        "id": 3,
        "title": "Create Envelope Summary Card Component",
        "description": "Develop the EnvelopeSummaryCard component that displays envelope information with edit and delete actions, matching the established UI pattern from income/expenses.",
        "details": "Create a new component that displays envelope information in a card format with edit and delete actions:\n\n```typescript\n// src/components/budget-setup/envelope-summary-card.tsx\nimport { Button } from \"@/components/ui/button\";\nimport { Card } from \"@/components/ui/card\";\nimport { formatCurrency } from \"@/lib/utils\";\n\ninterface EnvelopeSummaryCardProps {\n  envelope: {\n    id: string;\n    name: string;\n    default_amount: number;\n    rollover_rule: 'always_rollover' | 'rollover_limit' | 'always_to_savings';\n    rollover_limit?: number;\n  };\n  onEdit: () => void;\n  onDelete: () => void;\n}\n\nexport function EnvelopeSummaryCard({ envelope, onEdit, onDelete }: EnvelopeSummaryCardProps) {\n  // Format rollover rule for display\n  const getRolloverText = () => {\n    switch (envelope.rollover_rule) {\n      case 'always_rollover':\n        return 'Always rolls over';\n      case 'rollover_limit':\n        return `Rolls over up to ${formatCurrency(envelope.rollover_limit || 0)}`;\n      case 'always_to_savings':\n        return 'Excess goes to savings';\n      default:\n        return '';\n    }\n  };\n\n  return (\n    <Card className=\"p-4 mb-4\">\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h3 className=\"font-medium\">{envelope.name}</h3>\n          <p className=\"text-sm text-muted-foreground\">\n            {formatCurrency(envelope.default_amount)} per period\n          </p>\n          <p className=\"text-xs text-muted-foreground\">\n            {getRolloverText()}\n          </p>\n        </div>\n        <div className=\"flex gap-2\">\n          <Button size=\"sm\" variant=\"outline\" onClick={onEdit}>Edit</Button>\n          <Button size=\"sm\" variant=\"destructive\" onClick={onDelete}>Delete</Button>\n        </div>\n      </div>\n    </Card>\n  );\n}\n```",
        "testStrategy": "1. Unit test the EnvelopeSummaryCard component:\n   - Verify it renders correctly with all envelope data\n   - Test all rollover rule display variations\n   - Verify edit and delete buttons trigger the correct callbacks\n   - Test responsive layout on different screen sizes\n2. Visual regression tests to ensure the card matches the established UI pattern\n3. Accessibility testing for proper contrast, focus states, and screen reader support",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create Envelope Form Component",
        "description": "Develop the EnvelopeForm component for adding and editing envelopes with proper validation and user guidance.",
        "details": "Create a form component for adding and editing envelopes with validation:\n\n```typescript\n// src/components/budget-setup/envelope-form.tsx\nimport { zodResolver } from \"@zodResolver/form\";\nimport { useForm } from \"react-hook-form\";\nimport { z } from \"zod\";\nimport { Button } from \"@/components/ui/button\";\nimport { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Loader2 } from \"lucide-react\";\n\n// Validation schema\nconst envelopeSchema = z.object({\n  id: z.string().optional(),\n  name: z.string().min(1, \"Name is required\"),\n  default_amount: z.coerce.number().positive(\"Amount must be greater than 0\"),\n  rollover_rule: z.enum([\"always_rollover\", \"rollover_limit\", \"always_to_savings\"]),\n  rollover_limit: z.coerce.number().positive().optional().nullable(),\n  household_id: z.string()\n});\n\ntype EnvelopeFormValues = z.infer<typeof envelopeSchema>;\n\ninterface EnvelopeFormProps {\n  envelope?: EnvelopeFormValues;\n  householdId: string;\n  onSave: (envelope: EnvelopeFormValues) => void;\n  onCancel: () => void;\n  saving: boolean;\n}\n\nexport function EnvelopeForm({ envelope, householdId, onSave, onCancel, saving }: EnvelopeFormProps) {\n  // Default values\n  const defaultValues: Partial<EnvelopeFormValues> = {\n    name: \"\",\n    default_amount: 0,\n    rollover_rule: \"always_rollover\",\n    rollover_limit: null,\n    household_id: householdId,\n    ...envelope\n  };\n\n  const form = useForm<EnvelopeFormValues>({\n    resolver: zodResolver(envelopeSchema),\n    defaultValues,\n  });\n\n  // Watch rollover rule to conditionally show rollover limit\n  const rolloverRule = form.watch(\"rollover_rule\");\n  const showRolloverLimit = rolloverRule === \"rollover_limit\";\n\n  // Handle form submission\n  const onSubmit = (values: EnvelopeFormValues) => {\n    // If rollover rule is not rollover_limit, set limit to null\n    if (values.rollover_rule !== \"rollover_limit\") {\n      values.rollover_limit = null;\n    }\n    onSave(values);\n  };\n\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n        <FormField\n          control={form.control}\n          name=\"name\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Envelope Name</FormLabel>\n              <FormControl>\n                <Input placeholder=\"Groceries\" {...field} />\n              </FormControl>\n              <FormDescription>\n                Name for this spending category (e.g., Groceries, Fun Money)\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        <FormField\n          control={form.control}\n          name=\"default_amount\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Amount per Period</FormLabel>\n              <FormControl>\n                <Input type=\"number\" min=\"0\" step=\"0.01\" {...field} />\n              </FormControl>\n              <FormDescription>\n                How much to allocate to this envelope each paycheck period\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        <FormField\n          control={form.control}\n          name=\"rollover_rule\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Rollover Rule</FormLabel>\n              <Select\n                onValueChange={field.onChange}\n                defaultValue={field.value}\n              >\n                <FormControl>\n                  <SelectTrigger>\n                    <SelectValue placeholder=\"Select a rollover rule\" />\n                  </SelectTrigger>\n                </FormControl>\n                <SelectContent>\n                  <SelectItem value=\"always_rollover\">Always Rollover</SelectItem>\n                  <SelectItem value=\"rollover_limit\">Rollover with Limit</SelectItem>\n                  <SelectItem value=\"always_to_savings\">Always to Savings</SelectItem>\n                </SelectContent>\n              </Select>\n              <FormDescription>\n                {field.value === \"always_rollover\" && \"Unused funds always roll over to the next period\"}\n                {field.value === \"rollover_limit\" && \"Unused funds roll over up to a specified limit\"}\n                {field.value === \"always_to_savings\" && \"Unused funds always go to savings\"}\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        {showRolloverLimit && (\n          <FormField\n            control={form.control}\n            name=\"rollover_limit\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Rollover Limit</FormLabel>\n                <FormControl>\n                  <Input type=\"number\" min=\"0\" step=\"0.01\" {...field} value={field.value || ''} />\n                </FormControl>\n                <FormDescription>\n                  Maximum amount that can roll over to the next period\n                </FormDescription>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n        )}\n\n        <div className=\"flex gap-2\">\n          <Button type=\"submit\" disabled={saving}>\n            {saving ? <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" /> : null}\n            Save\n          </Button>\n          <Button type=\"button\" variant=\"outline\" onClick={onCancel}>\n            Cancel\n          </Button>\n        </div>\n      </form>\n    </Form>\n  );\n}\n```",
        "testStrategy": "1. Unit test the EnvelopeForm component:\n   - Test form validation for required fields\n   - Test conditional rendering of rollover limit field\n   - Verify form submission with correct values\n   - Test form cancellation\n2. Integration test with mock API calls\n3. Test form behavior with different initial values\n4. Verify proper handling of loading states during save operations\n5. Test form accessibility including keyboard navigation and screen reader support",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Envelope Step Integration",
        "description": "Update the StepEnvelopes component to use the new EnvelopeSummaryCard and EnvelopeForm components with proper state management and API integration.",
        "details": "Implement the StepEnvelopes component that integrates the new envelope components with proper state management and API calls:\n\n```typescript\n// src/components/budget-setup/step-envelopes.tsx\nimport { useState, useEffect } from \"react\";\nimport { useUser } from \"@/hooks/useUser\";\nimport { Button } from \"@/components/ui/button\";\nimport { EnvelopeSummaryCard } from \"./envelope-summary-card\";\nimport { EnvelopeForm } from \"./envelope-form\";\nimport { supabase } from \"@/lib/supabase\";\nimport { Loader2 } from \"lucide-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\n\n// Default envelope suggestions\nconst DEFAULT_ENVELOPES = [\n  { name: \"Groceries\", default_amount: 300, rollover_rule: \"rollover_limit\", rollover_limit: 100 },\n  { name: \"Household & Maintenance\", default_amount: 100, rollover_rule: \"rollover_limit\", rollover_limit: 50 },\n  { name: \"Fun Money\", default_amount: 150, rollover_rule: \"always_to_savings\" },\n  { name: \"Dining Out\", default_amount: 100, rollover_rule: \"always_to_savings\" },\n  { name: \"Personal Care\", default_amount: 75, rollover_rule: \"rollover_limit\", rollover_limit: 25 },\n  { name: \"Miscellaneous\", default_amount: 50, rollover_rule: \"always_rollover\" }\n];\n\nexport function StepEnvelopes() {\n  const { user, householdId, loading: userLoading } = useUser();\n  \n  const [state, setState] = useState({\n    envelopes: [],\n    editingEnvelope: null,\n    addingNewEnvelope: false,\n    loading: true,\n    saving: false,\n    error: null\n  });\n  \n  // Load envelopes on component mount\n  useEffect(() => {\n    if (householdId) {\n      loadEnvelopes();\n    }\n  }, [householdId]);\n  \n  // Load envelopes from database\n  const loadEnvelopes = async () => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    \n    try {\n      const { data, error } = await supabase\n        .from('envelopes')\n        .select('*')\n        .eq('household_id', householdId)\n        .eq('is_active', true)\n        .order('sort_order');\n      \n      if (error) throw error;\n      \n      setState(prev => ({\n        ...prev,\n        envelopes: data || [],\n        loading: false\n      }));\n    } catch (error) {\n      console.error('Error loading envelopes:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'Failed to load envelopes. Please try again.',\n        loading: false\n      }));\n    }\n  };\n  \n  // Handle adding a new envelope\n  const handleAddNew = () => {\n    setState(prev => ({\n      ...prev,\n      addingNewEnvelope: true,\n      editingEnvelope: null\n    }));\n  };\n  \n  // Handle editing an envelope\n  const handleEdit = (envelope) => {\n    setState(prev => ({\n      ...prev,\n      editingEnvelope: envelope,\n      addingNewEnvelope: false\n    }));\n  };\n  \n  // Handle canceling add/edit\n  const handleCancel = () => {\n    setState(prev => ({\n      ...prev,\n      editingEnvelope: null,\n      addingNewEnvelope: false\n    }));\n  };\n  \n  // Handle saving an envelope\n  const handleSave = async (envelope) => {\n    setState(prev => ({ ...prev, saving: true, error: null }));\n    \n    try {\n      // Add household_id if not present\n      if (!envelope.household_id) {\n        envelope.household_id = householdId;\n      }\n      \n      // Add sort_order if new envelope\n      if (!envelope.id) {\n        envelope.sort_order = state.envelopes.length;\n        envelope.is_active = true;\n      }\n      \n      const { data, error } = await supabase\n        .from('envelopes')\n        .upsert(envelope)\n        .select()\n        .single();\n      \n      if (error) throw error;\n      \n      // Update local state\n      setState(prev => {\n        const updatedEnvelopes = envelope.id\n          ? prev.envelopes.map(e => e.id === envelope.id ? data : e)\n          : [...prev.envelopes, data];\n        \n        return {\n          ...prev,\n          envelopes: updatedEnvelopes,\n          editingEnvelope: null,\n          addingNewEnvelope: false,\n          saving: false\n        };\n      });\n    } catch (error) {\n      console.error('Error saving envelope:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'Failed to save envelope. Please try again.',\n        saving: false\n      }));\n    }\n  };\n  \n  // Handle deleting an envelope\n  const handleDelete = async (envelope) => {\n    if (!confirm('Are you sure you want to delete this envelope?')) return;\n    \n    setState(prev => ({ ...prev, saving: true, error: null }));\n    \n    try {\n      const { error } = await supabase\n        .from('envelopes')\n        .update({ is_active: false })\n        .eq('id', envelope.id);\n      \n      if (error) throw error;\n      \n      // Update local state\n      setState(prev => ({\n        ...prev,\n        envelopes: prev.envelopes.filter(e => e.id !== envelope.id),\n        saving: false\n      }));\n    } catch (error) {\n      console.error('Error deleting envelope:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'Failed to delete envelope. Please try again.',\n        saving: false\n      }));\n    }\n  };\n  \n  // Handle adding default envelopes\n  const handleAddDefaults = async () => {\n    setState(prev => ({ ...prev, saving: true, error: null }));\n    \n    try {\n      const defaultsWithHouseholdId = DEFAULT_ENVELOPES.map((envelope, index) => ({\n        ...envelope,\n        household_id: householdId,\n        sort_order: index,\n        is_active: true\n      }));\n      \n      const { data, error } = await supabase\n        .from('envelopes')\n        .insert(defaultsWithHouseholdId)\n        .select();\n      \n      if (error) throw error;\n      \n      // Update local state\n      setState(prev => ({\n        ...prev,\n        envelopes: [...prev.envelopes, ...data],\n        saving: false\n      }));\n    } catch (error) {\n      console.error('Error adding default envelopes:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'Failed to add default envelopes. Please try again.',\n        saving: false\n      }));\n    }\n  };\n  \n  // Show loading state\n  if (userLoading || state.loading) {\n    return (\n      <div className=\"flex justify-center items-center h-64\">\n        <Loader2 className=\"w-8 h-8 animate-spin\" />\n      </div>\n    );\n  }\n  \n  // Show error state\n  if (state.error) {\n    return (\n      <Alert variant=\"destructive\">\n        <AlertDescription>{state.error}</AlertDescription>\n      </Alert>\n    );\n  }\n  \n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <h2 className=\"text-2xl font-bold\">Spending Envelopes</h2>\n        <div className=\"flex gap-2\">\n          {state.envelopes.length === 0 && (\n            <Button onClick={handleAddDefaults} variant=\"outline\">\n              Add Suggested Envelopes\n            </Button>\n          )}\n          <Button onClick={handleAddNew}>\n            Add New Envelope\n          </Button>\n        </div>\n      </div>\n      \n      {state.envelopes.length === 0 && !state.addingNewEnvelope && (\n        <div className=\"text-center p-8 border rounded-md bg-muted/20\">\n          <p className=\"text-muted-foreground\">No envelopes yet. Add your first envelope or use our suggested defaults.</p>\n        </div>\n      )}\n      \n      {/* Show form when adding or editing */}\n      {(state.addingNewEnvelope || state.editingEnvelope) && (\n        <EnvelopeForm\n          envelope={state.editingEnvelope}\n          householdId={householdId}\n          onSave={handleSave}\n          onCancel={handleCancel}\n          saving={state.saving}\n        />\n      )}\n      \n      {/* Show envelope cards when not adding/editing */}\n      {!state.addingNewEnvelope && !state.editingEnvelope && (\n        <div className=\"space-y-4\">\n          {state.envelopes.map(envelope => (\n            <EnvelopeSummaryCard\n              key={envelope.id}\n              envelope={envelope}\n              onEdit={() => handleEdit(envelope)}\n              onDelete={() => handleDelete(envelope)}\n            />\n          ))}\n        </div>\n      )}\n      \n      {/* Help text */}\n      <div className=\"mt-8 p-4 bg-muted/20 rounded-md\">\n        <h3 className=\"font-medium mb-2\">About Spending Envelopes</h3>\n        <p className=\"text-sm text-muted-foreground mb-2\">\n          Envelopes are spending categories for day-to-day expenses. Each envelope gets a set amount per paycheck period.\n        </p>\n        <p className=\"text-sm text-muted-foreground\">\n          <strong>Note:</strong> Savings goals (like Emergency Fund or Vacation) should be created in the next step, not as envelopes.\n        </p>\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Integration test the StepEnvelopes component:\n   - Test loading envelopes from the database\n   - Test adding a new envelope\n   - Test editing an existing envelope\n   - Test deleting an envelope\n   - Test adding default envelopes\n2. Test error handling for API failures\n3. Test state transitions between viewing, adding, and editing modes\n4. Verify data persistence across step navigation\n5. Test performance with a large number of envelopes\n6. Test responsive layout on different screen sizes",
        "priority": "medium",
        "dependencies": [
          1,
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create Savings Goal Summary Card Component",
        "description": "Develop the SavingsGoalSummaryCard component that displays savings goal information with progress tracking and edit/delete actions.",
        "details": "Create a new component that displays savings goal information with progress tracking:\n\n```typescript\n// src/components/budget-setup/savings-goal-summary-card.tsx\nimport { Button } from \"@/components/ui/button\";\nimport { Card } from \"@/components/ui/card\";\nimport { Progress } from \"@/components/ui/progress\";\nimport { formatCurrency } from \"@/lib/utils\";\nimport { ShieldCheck } from \"lucide-react\";\n\ninterface SavingsGoalSummaryCardProps {\n  goal: {\n    id: string;\n    name: string;\n    target_amount: number;\n    current_balance: number;\n    target_date?: string;\n    is_emergency_fund: boolean;\n  };\n  onEdit: () => void;\n  onDelete: () => void;\n}\n\nexport function SavingsGoalSummaryCard({ goal, onEdit, onDelete }: SavingsGoalSummaryCardProps) {\n  // Calculate progress percentage\n  const progressPercentage = goal.target_amount > 0\n    ? Math.min(Math.round((goal.current_balance / goal.target_amount) * 100), 100)\n    : 0;\n  \n  // Format target date if present\n  const formattedDate = goal.target_date\n    ? new Date(goal.target_date).toLocaleDateString()\n    : null;\n  \n  return (\n    <Card className=\"p-4 mb-4\">\n      <div className=\"space-y-3\">\n        <div className=\"flex justify-between items-center\">\n          <div className=\"flex items-center gap-2\">\n            {goal.is_emergency_fund && (\n              <ShieldCheck className=\"h-5 w-5 text-primary\" />\n            )}\n            <h3 className=\"font-medium\">{goal.name}</h3>\n          </div>\n          <div className=\"flex gap-2\">\n            <Button size=\"sm\" variant=\"outline\" onClick={onEdit}>Edit</Button>\n            <Button size=\"sm\" variant=\"destructive\" onClick={onDelete}>Delete</Button>\n          </div>\n        </div>\n        \n        <div className=\"space-y-1\">\n          <div className=\"flex justify-between text-sm\">\n            <span>Progress: {formatCurrency(goal.current_balance)} of {formatCurrency(goal.target_amount)}</span>\n            <span>{progressPercentage}%</span>\n          </div>\n          <Progress value={progressPercentage} className=\"h-2\" />\n        </div>\n        \n        {formattedDate && (\n          <p className=\"text-xs text-muted-foreground\">\n            Target date: {formattedDate}\n          </p>\n        )}\n        \n        {goal.is_emergency_fund && (\n          <p className=\"text-xs text-primary\">\n            Emergency Fund\n          </p>\n        )}\n      </div>\n    </Card>\n  );\n}\n```",
        "testStrategy": "1. Unit test the SavingsGoalSummaryCard component:\n   - Verify it renders correctly with all goal data\n   - Test progress calculation and display\n   - Test emergency fund indicator display\n   - Test target date formatting\n   - Verify edit and delete buttons trigger the correct callbacks\n2. Visual regression tests to ensure the card matches the established UI pattern\n3. Accessibility testing for proper contrast, focus states, and screen reader support\n4. Test edge cases like 0% progress, 100% progress, and missing target date",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create Savings Goal Form Component",
        "description": "Develop the SavingsGoalForm component for adding and editing savings goals with proper validation and user guidance.",
        "details": "Create a form component for adding and editing savings goals with validation:\n\n```typescript\n// src/components/budget-setup/savings-goal-form.tsx\nimport { zodResolver } from \"@zodResolver/form\";\nimport { useForm } from \"react-hook-form\";\nimport { z } from \"zod\";\nimport { Button } from \"@/components/ui/button\";\nimport { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport { Loader2 } from \"lucide-react\";\n\n// Validation schema\nconst savingsGoalSchema = z.object({\n  id: z.string().optional(),\n  name: z.string().min(1, \"Name is required\"),\n  target_amount: z.coerce.number().positive(\"Target amount must be greater than 0\"),\n  current_balance: z.coerce.number().min(0, \"Current balance cannot be negative\"),\n  target_date: z.string().optional().nullable(),\n  is_emergency_fund: z.boolean().default(false),\n  household_id: z.string()\n});\n\ntype SavingsGoalFormValues = z.infer<typeof savingsGoalSchema>;\n\ninterface SavingsGoalFormProps {\n  goal?: SavingsGoalFormValues;\n  householdId: string;\n  onSave: (goal: SavingsGoalFormValues) => void;\n  onCancel: () => void;\n  saving: boolean;\n}\n\nexport function SavingsGoalForm({ goal, householdId, onSave, onCancel, saving }: SavingsGoalFormProps) {\n  // Default values\n  const defaultValues: Partial<SavingsGoalFormValues> = {\n    name: \"\",\n    target_amount: 0,\n    current_balance: 0,\n    target_date: null,\n    is_emergency_fund: false,\n    household_id: householdId,\n    ...goal\n  };\n\n  const form = useForm<SavingsGoalFormValues>({\n    resolver: zodResolver(savingsGoalSchema),\n    defaultValues,\n  });\n\n  // Handle form submission\n  const onSubmit = (values: SavingsGoalFormValues) => {\n    // If target date is empty string, set to null\n    if (values.target_date === \"\") {\n      values.target_date = null;\n    }\n    onSave(values);\n  };\n\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n        <FormField\n          control={form.control}\n          name=\"name\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Goal Name</FormLabel>\n              <FormControl>\n                <Input placeholder=\"Emergency Fund\" {...field} />\n              </FormControl>\n              <FormDescription>\n                Name for this savings goal (e.g., Emergency Fund, Vacation)\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        <FormField\n          control={form.control}\n          name=\"target_amount\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Target Amount</FormLabel>\n              <FormControl>\n                <Input type=\"number\" min=\"0\" step=\"0.01\" {...field} />\n              </FormControl>\n              <FormDescription>\n                Total amount you want to save for this goal\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        <FormField\n          control={form.control}\n          name=\"current_balance\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Current Balance</FormLabel>\n              <FormControl>\n                <Input type=\"number\" min=\"0\" step=\"0.01\" {...field} />\n              </FormControl>\n              <FormDescription>\n                How much you've already saved toward this goal\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        <FormField\n          control={form.control}\n          name=\"target_date\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Target Date (Optional)</FormLabel>\n              <FormControl>\n                <Input type=\"date\" {...field} value={field.value || ''} />\n              </FormControl>\n              <FormDescription>\n                When you want to reach this savings goal\n              </FormDescription>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        <FormField\n          control={form.control}\n          name=\"is_emergency_fund\"\n          render={({ field }) => (\n            <FormItem className=\"flex flex-row items-start space-x-3 space-y-0 rounded-md border p-4\">\n              <FormControl>\n                <Checkbox\n                  checked={field.value}\n                  onCheckedChange={field.onChange}\n                />\n              </FormControl>\n              <div className=\"space-y-1 leading-none\">\n                <FormLabel>\n                  This is an emergency fund\n                </FormLabel>\n                <FormDescription>\n                  Emergency funds are prioritized and should be funded before other goals\n                </FormDescription>\n              </div>\n            </FormItem>\n          )}\n        />\n\n        <div className=\"flex gap-2\">\n          <Button type=\"submit\" disabled={saving}>\n            {saving ? <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" /> : null}\n            Save\n          </Button>\n          <Button type=\"button\" variant=\"outline\" onClick={onCancel}>\n            Cancel\n          </Button>\n        </div>\n      </form>\n    </Form>\n  );\n}\n```",
        "testStrategy": "1. Unit test the SavingsGoalForm component:\n   - Test form validation for required fields\n   - Test form submission with correct values\n   - Test form cancellation\n   - Test emergency fund checkbox functionality\n2. Integration test with mock API calls\n3. Test form behavior with different initial values\n4. Verify proper handling of loading states during save operations\n5. Test form accessibility including keyboard navigation and screen reader support\n6. Test date input formatting and validation",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Savings Goals Step Integration",
        "description": "Update the StepSavingsGoals component to use the new SavingsGoalSummaryCard and SavingsGoalForm components with proper state management and API integration.",
        "details": "Implement the StepSavingsGoals component that integrates the new savings goal components with proper state management and API calls:\n\n```typescript\n// src/components/budget-setup/step-savings-goals.tsx\nimport { useState, useEffect } from \"react\";\nimport { useUser } from \"@/hooks/useUser\";\nimport { Button } from \"@/components/ui/button\";\nimport { SavingsGoalSummaryCard } from \"./savings-goal-summary-card\";\nimport { SavingsGoalForm } from \"./savings-goal-form\";\nimport { supabase } from \"@/lib/supabase\";\nimport { Loader2 } from \"lucide-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\n\n// Default savings goals\nconst DEFAULT_SAVINGS_GOALS = [\n  { name: \"Emergency Fund\", target_amount: 10000, current_balance: 0, is_emergency_fund: true },\n  { name: \"Vacation\", target_amount: 2000, current_balance: 0, is_emergency_fund: false },\n  { name: \"Car Replacement\", target_amount: 5000, current_balance: 0, is_emergency_fund: false }\n];\n\nexport function StepSavingsGoals() {\n  const { user, householdId, loading: userLoading } = useUser();\n  \n  const [state, setState] = useState({\n    goals: [],\n    editingGoal: null,\n    addingNewGoal: false,\n    loading: true,\n    saving: false,\n    error: null\n  });\n  \n  // Load savings goals on component mount\n  useEffect(() => {\n    if (householdId) {\n      loadSavingsGoals();\n    }\n  }, [householdId]);\n  \n  // Load savings goals from database\n  const loadSavingsGoals = async () => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    \n    try {\n      const { data, error } = await supabase\n        .from('savings_goals')\n        .select('*')\n        .eq('household_id', householdId)\n        .eq('is_active', true)\n        .order('sort_order');\n      \n      if (error) throw error;\n      \n      setState(prev => ({\n        ...prev,\n        goals: data || [],\n        loading: false\n      }));\n    } catch (error) {\n      console.error('Error loading savings goals:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'Failed to load savings goals. Please try again.',\n        loading: false\n      }));\n    }\n  };\n  \n  // Handle adding a new savings goal\n  const handleAddNew = () => {\n    setState(prev => ({\n      ...prev,\n      addingNewGoal: true,\n      editingGoal: null\n    }));\n  };\n  \n  // Handle editing a savings goal\n  const handleEdit = (goal) => {\n    setState(prev => ({\n      ...prev,\n      editingGoal: goal,\n      addingNewGoal: false\n    }));\n  };\n  \n  // Handle canceling add/edit\n  const handleCancel = () => {\n    setState(prev => ({\n      ...prev,\n      editingGoal: null,\n      addingNewGoal: false\n    }));\n  };\n  \n  // Handle saving a savings goal\n  const handleSave = async (goal) => {\n    setState(prev => ({ ...prev, saving: true, error: null }));\n    \n    try {\n      // Add household_id if not present\n      if (!goal.household_id) {\n        goal.household_id = householdId;\n      }\n      \n      // Add sort_order if new goal\n      if (!goal.id) {\n        goal.sort_order = state.goals.length;\n        goal.is_active = true;\n      }\n      \n      const { data, error } = await supabase\n        .from('savings_goals')\n        .upsert(goal)\n        .select()\n        .single();\n      \n      if (error) throw error;\n      \n      // Update local state\n      setState(prev => {\n        const updatedGoals = goal.id\n          ? prev.goals.map(g => g.id === goal.id ? data : g)\n          : [...prev.goals, data];\n        \n        return {\n          ...prev,\n          goals: updatedGoals,\n          editingGoal: null,\n          addingNewGoal: false,\n          saving: false\n        };\n      });\n    } catch (error) {\n      console.error('Error saving savings goal:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'Failed to save savings goal. Please try again.',\n        saving: false\n      }));\n    }\n  };\n  \n  // Handle deleting a savings goal\n  const handleDelete = async (goal) => {\n    if (!confirm('Are you sure you want to delete this savings goal?')) return;\n    \n    setState(prev => ({ ...prev, saving: true, error: null }));\n    \n    try {\n      const { error } = await supabase\n        .from('savings_goals')\n        .update({ is_active: false })\n        .eq('id', goal.id);\n      \n      if (error) throw error;\n      \n      // Update local state\n      setState(prev => ({\n        ...prev,\n        goals: prev.goals.filter(g => g.id !== goal.id),\n        saving: false\n      }));\n    } catch (error) {\n      console.error('Error deleting savings goal:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'Failed to delete savings goal. Please try again.',\n        saving: false\n      }));\n    }\n  };\n  \n  // Handle adding default savings goals\n  const handleAddDefaults = async () => {\n    setState(prev => ({ ...prev, saving: true, error: null }));\n    \n    try {\n      const defaultsWithHouseholdId = DEFAULT_SAVINGS_GOALS.map((goal, index) => ({\n        ...goal,\n        household_id: householdId,\n        sort_order: index,\n        is_active: true\n      }));\n      \n      const { data, error } = await supabase\n        .from('savings_goals')\n        .insert(defaultsWithHouseholdId)\n        .select();\n      \n      if (error) throw error;\n      \n      // Update local state\n      setState(prev => ({\n        ...prev,\n        goals: [...prev.goals, ...data],\n        saving: false\n      }));\n    } catch (error) {\n      console.error('Error adding default savings goals:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'Failed to add default savings goals. Please try again.',\n        saving: false\n      }));\n    }\n  };\n  \n  // Check if there's at least one emergency fund\n  const hasEmergencyFund = state.goals.some(goal => goal.is_emergency_fund);\n  \n  // Show loading state\n  if (userLoading || state.loading) {\n    return (\n      <div className=\"flex justify-center items-center h-64\">\n        <Loader2 className=\"w-8 h-8 animate-spin\" />\n      </div>\n    );\n  }\n  \n  // Show error state\n  if (state.error) {\n    return (\n      <Alert variant=\"destructive\">\n        <AlertDescription>{state.error}</AlertDescription>\n      </Alert>\n    );\n  }\n  \n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <h2 className=\"text-2xl font-bold\">Savings Goals</h2>\n        <div className=\"flex gap-2\">\n          {state.goals.length === 0 && (\n            <Button onClick={handleAddDefaults} variant=\"outline\">\n              Add Suggested Goals\n            </Button>\n          )}\n          <Button onClick={handleAddNew}>\n            Add New Goal\n          </Button>\n        </div>\n      </div>\n      \n      {!hasEmergencyFund && state.goals.length > 0 && !state.addingNewGoal && !state.editingGoal && (\n        <Alert>\n          <AlertDescription>\n            We recommend having at least one emergency fund. Add one by clicking \"Add New Goal\".\n          </AlertDescription>\n        </Alert>\n      )}\n      \n      {state.goals.length === 0 && !state.addingNewGoal && (\n        <div className=\"text-center p-8 border rounded-md bg-muted/20\">\n          <p className=\"text-muted-foreground\">No savings goals yet. Add your first goal or use our suggested defaults.</p>\n        </div>\n      )}\n      \n      {/* Show form when adding or editing */}\n      {(state.addingNewGoal || state.editingGoal) && (\n        <SavingsGoalForm\n          goal={state.editingGoal}\n          householdId={householdId}\n          onSave={handleSave}\n          onCancel={handleCancel}\n          saving={state.saving}\n        />\n      )}\n      \n      {/* Show savings goal cards when not adding/editing */}\n      {!state.addingNewGoal && !state.editingGoal && (\n        <div className=\"space-y-4\">\n          {state.goals.map(goal => (\n            <SavingsGoalSummaryCard\n              key={goal.id}\n              goal={goal}\n              onEdit={() => handleEdit(goal)}\n              onDelete={() => handleDelete(goal)}\n            />\n          ))}\n        </div>\n      )}\n      \n      {/* Help text */}\n      <div className=\"mt-8 p-4 bg-muted/20 rounded-md\">\n        <h3 className=\"font-medium mb-2\">About Savings Goals</h3>\n        <p className=\"text-sm text-muted-foreground mb-2\">\n          Savings goals are for long-term saving, not day-to-day spending. Examples include Emergency Fund, Vacation, or Car Replacement.\n        </p>\n        <p className=\"text-sm text-muted-foreground\">\n          <strong>Tip:</strong> We recommend having at least one emergency fund with 3-6 months of expenses as your target.\n        </p>\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Integration test the StepSavingsGoals component:\n   - Test loading savings goals from the database\n   - Test adding a new savings goal\n   - Test editing an existing savings goal\n   - Test deleting a savings goal\n   - Test adding default savings goals\n   - Test emergency fund detection and alert\n2. Test error handling for API failures\n3. Test state transitions between viewing, adding, and editing modes\n4. Verify data persistence across step navigation\n5. Test performance with a large number of savings goals\n6. Test responsive layout on different screen sizes",
        "priority": "medium",
        "dependencies": [
          1,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Update Database Schema for Frequency System",
        "description": "Extend the frequency system to envelopes and savings goals tables for consistency with income sources and fixed expenses.",
        "details": "Update the database schema to add frequency-related columns to envelopes and savings goals tables:\n\n```sql\n-- Ensure envelopes table supports frequency for recurring allocations\nALTER TABLE envelopes ADD COLUMN IF NOT EXISTS frequency_type text;\nALTER TABLE envelopes ADD COLUMN IF NOT EXISTS frequency_config jsonb;\n\n-- Ensure savings_goals table supports frequency for recurring contributions\nALTER TABLE savings_goals ADD COLUMN IF NOT EXISTS frequency_type text;\nALTER TABLE savings_goals ADD COLUMN IF NOT EXISTS frequency_config jsonb;\n```\n\nImplement the migration in a Supabase migration file:\n\n```typescript\n// src/lib/migrations/extend-frequency-system.ts\nimport { supabase } from \"@/lib/supabase\";\n\nexport async function extendFrequencySystem() {\n  try {\n    // Add frequency columns to envelopes table\n    await supabase.rpc('add_column_if_not_exists', {\n      table_name: 'envelopes',\n      column_name: 'frequency_type',\n      column_type: 'text'\n    });\n    \n    await supabase.rpc('add_column_if_not_exists', {\n      table_name: 'envelopes',\n      column_name: 'frequency_config',\n      column_type: 'jsonb'\n    });\n    \n    // Add frequency columns to savings_goals table\n    await supabase.rpc('add_column_if_not_exists', {\n      table_name: 'savings_goals',\n      column_name: 'frequency_type',\n      column_type: 'text'\n    });\n    \n    await supabase.rpc('add_column_if_not_exists', {\n      table_name: 'savings_goals',\n      column_name: 'frequency_config',\n      column_type: 'jsonb'\n    });\n    \n    console.log('Successfully extended frequency system to envelopes and savings goals');\n    return { success: true };\n  } catch (error) {\n    console.error('Error extending frequency system:', error);\n    return { success: false, error };\n  }\n}\n```\n\nCreate a stored procedure in Supabase for adding columns if they don't exist:\n\n```sql\n-- Create a function to add a column if it doesn't exist\nCREATE OR REPLACE FUNCTION add_column_if_not_exists(\n  table_name text,\n  column_name text,\n  column_type text\n) RETURNS void AS $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.columns\n    WHERE table_name = $1\n    AND column_name = $2\n  ) THEN\n    EXECUTE format('ALTER TABLE %I ADD COLUMN %I %s', $1, $2, $3);\n  END IF;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n```\n\nUpdate the frequency-related types to include these new tables:\n\n```typescript\n// src/types/frequency.ts\nexport type FrequencyType = 'weekly' | 'biweekly' | 'monthly' | 'quarterly' | 'annual' | 'custom';\n\nexport interface FrequencyConfig {\n  custom_type?: 'days' | 'weeks' | 'months';\n  custom_interval?: number;\n  start_date?: string;\n  day_of_month?: number;\n  day_of_week?: number;\n}\n\nexport interface FrequencyItem {\n  frequency_type: FrequencyType;\n  frequency_config: FrequencyConfig;\n}\n```",
        "testStrategy": "1. Test the migration script in a development environment before running in production\n2. Verify that existing data is not affected by the schema changes\n3. Test the add_column_if_not_exists function with various table and column combinations\n4. Verify that the new columns are properly created in both tables\n5. Test inserting and querying data with the new frequency columns\n6. Create a rollback plan in case the migration fails",
        "priority": "low",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement End-to-End Budget Setup Flow Integration",
        "description": "Ensure seamless navigation between all budget setup steps with proper data persistence, validation, and completion handling.",
        "details": "Implement the budget setup flow integration to ensure seamless navigation between steps with proper data persistence:\n\n```typescript\n// src/components/budget-setup/budget-setup-flow.tsx\nimport { useState, useEffect } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { useUser } from \"@/hooks/useUser\";\nimport { Button } from \"@/components/ui/button\";\nimport { StepIncome } from \"./step-income\";\nimport { StepFixedExpenses } from \"./step-fixed-expenses\";\nimport { StepEnvelopes } from \"./step-envelopes\";\nimport { StepSavingsGoals } from \"./step-savings-goals\";\nimport { supabase } from \"@/lib/supabase\";\nimport { Loader2 } from \"lucide-react\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\n\nconst STEPS = [\n  { id: 'income', label: 'Income Sources', component: StepIncome },\n  { id: 'expenses', label: 'Fixed Expenses', component: StepFixedExpenses },\n  { id: 'envelopes', label: 'Envelopes', component: StepEnvelopes },\n  { id: 'savings', label: 'Savings Goals', component: StepSavingsGoals }\n];\n\nexport function BudgetSetupFlow() {\n  const router = useRouter();\n  const { user, householdId, loading: userLoading } = useUser();\n  \n  const [state, setState] = useState({\n    currentStepIndex: 0,\n    stepsCompleted: {\n      income: false,\n      expenses: false,\n      envelopes: false,\n      savings: false\n    },\n    loading: true,\n    saving: false,\n    error: null\n  });\n  \n  // Load budget setup progress on component mount\n  useEffect(() => {\n    if (householdId) {\n      loadBudgetSetupProgress();\n    }\n  }, [householdId]);\n  \n  // Load budget setup progress from database\n  const loadBudgetSetupProgress = async () => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    \n    try {\n      // Check if each step has data\n      const [incomeResponse, expensesResponse, envelopesResponse, savingsResponse] = await Promise.all([\n        supabase.from('income_sources').select('id').eq('household_id', householdId).eq('is_active', true).limit(1),\n        supabase.from('fixed_expenses').select('id').eq('household_id', householdId).eq('is_active', true).limit(1),\n        supabase.from('envelopes').select('id').eq('household_id', householdId).eq('is_active', true).limit(1),\n        supabase.from('savings_goals').select('id').eq('household_id', householdId).eq('is_active', true).limit(1)\n      ]);\n      \n      // Check for errors\n      if (incomeResponse.error) throw incomeResponse.error;\n      if (expensesResponse.error) throw expensesResponse.error;\n      if (envelopesResponse.error) throw envelopesResponse.error;\n      if (savingsResponse.error) throw savingsResponse.error;\n      \n      // Update completed steps\n      setState(prev => ({\n        ...prev,\n        stepsCompleted: {\n          income: incomeResponse.data.length > 0,\n          expenses: expensesResponse.data.length > 0,\n          envelopes: envelopesResponse.data.length > 0,\n          savings: savingsResponse.data.length > 0\n        },\n        loading: false\n      }));\n      \n      // Find the first incomplete step\n      const firstIncompleteIndex = STEPS.findIndex(step => \n        !prev.stepsCompleted[step.id as keyof typeof prev.stepsCompleted]\n      );\n      \n      // If found, set as current step\n      if (firstIncompleteIndex !== -1) {\n        setState(prev => ({\n          ...prev,\n          currentStepIndex: firstIncompleteIndex\n        }));\n      }\n    } catch (error) {\n      console.error('Error loading budget setup progress:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'Failed to load budget setup progress. Please try again.',\n        loading: false\n      }));\n    }\n  };\n  \n  // Handle navigation to next step\n  const handleNext = () => {\n    if (state.currentStepIndex < STEPS.length - 1) {\n      setState(prev => ({\n        ...prev,\n        currentStepIndex: prev.currentStepIndex + 1\n      }));\n    } else {\n      // All steps completed, redirect to dashboard\n      handleComplete();\n    }\n  };\n  \n  // Handle navigation to previous step\n  const handlePrevious = () => {\n    if (state.currentStepIndex > 0) {\n      setState(prev => ({\n        ...prev,\n        currentStepIndex: prev.currentStepIndex - 1\n      }));\n    }\n  };\n  \n  // Handle completion of budget setup\n  const handleComplete = async () => {\n    setState(prev => ({ ...prev, saving: true, error: null }));\n    \n    try {\n      // Update household record to mark budget setup as complete\n      const { error } = await supabase\n        .from('households')\n        .update({ budget_setup_completed: true })\n        .eq('id', householdId);\n      \n      if (error) throw error;\n      \n      // Redirect to dashboard\n      router.push('/dashboard');\n    } catch (error) {\n      console.error('Error completing budget setup:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'Failed to complete budget setup. Please try again.',\n        saving: false\n      }));\n    }\n  };\n  \n  // Show loading state\n  if (userLoading || state.loading) {\n    return (\n      <div className=\"flex justify-center items-center h-64\">\n        <Loader2 className=\"w-8 h-8 animate-spin\" />\n      </div>\n    );\n  }\n  \n  // Show error state\n  if (state.error) {\n    return (\n      <Alert variant=\"destructive\">\n        <AlertDescription>{state.error}</AlertDescription>\n      </Alert>\n    );\n  }\n  \n  // Get current step\n  const currentStep = STEPS[state.currentStepIndex];\n  const CurrentStepComponent = currentStep.component;\n  const isLastStep = state.currentStepIndex === STEPS.length - 1;\n  \n  return (\n    <div className=\"space-y-8\">\n      {/* Progress indicator */}\n      <div className=\"flex justify-between mb-8\">\n        {STEPS.map((step, index) => (\n          <div \n            key={step.id} \n            className={`flex flex-col items-center ${index <= state.currentStepIndex ? 'text-primary' : 'text-muted-foreground'}`}\n          >\n            <div \n              className={`w-8 h-8 rounded-full flex items-center justify-center mb-2 ${index <= state.currentStepIndex ? 'bg-primary text-primary-foreground' : 'bg-muted text-muted-foreground'}`}\n            >\n              {index + 1}\n            </div>\n            <span className=\"text-sm\">{step.label}</span>\n          </div>\n        ))}\n      </div>\n      \n      {/* Current step content */}\n      <div>\n        <CurrentStepComponent />\n      </div>\n      \n      {/* Navigation buttons */}\n      <div className=\"flex justify-between pt-8 border-t\">\n        <Button \n          variant=\"outline\" \n          onClick={handlePrevious}\n          disabled={state.currentStepIndex === 0}\n        >\n          Previous\n        </Button>\n        \n        <Button \n          onClick={handleNext}\n          disabled={state.saving}\n        >\n          {state.saving ? <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" /> : null}\n          {isLastStep ? 'Complete Setup' : 'Next'}\n        </Button>\n      </div>\n    </div>\n  );\n}\n```\n\nCreate an API route for checking budget setup completion:\n\n```typescript\n// src/app/api/budget-setup/status/route.ts\nimport { NextResponse } from 'next/server';\nimport { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';\nimport { cookies } from 'next/headers';\n\nexport async function GET(request: Request) {\n  const supabase = createRouteHandlerClient({ cookies });\n  \n  try {\n    // Get user session\n    const { data: { session } } = await supabase.auth.getSession();\n    \n    if (!session) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    // Get user's household\n    const { data: householdMember, error: householdError } = await supabase\n      .from('household_members')\n      .select('household_id')\n      .eq('user_id', session.user.id)\n      .single();\n    \n    if (householdError || !householdMember) {\n      return NextResponse.json({ error: 'Household not found' }, { status: 404 });\n    }\n    \n    // Check budget setup status\n    const { data: household, error: statusError } = await supabase\n      .from('households')\n      .select('budget_setup_completed')\n      .eq('id', householdMember.household_id)\n      .single();\n    \n    if (statusError) {\n      return NextResponse.json({ error: 'Failed to check budget setup status' }, { status: 500 });\n    }\n    \n    // Check if each step has data\n    const [incomeResponse, expensesResponse, envelopesResponse, savingsResponse] = await Promise.all([\n      supabase.from('income_sources').select('id').eq('household_id', householdMember.household_id).eq('is_active', true).limit(1),\n      supabase.from('fixed_expenses').select('id').eq('household_id', householdMember.household_id).eq('is_active', true).limit(1),\n      supabase.from('envelopes').select('id').eq('household_id', householdMember.household_id).eq('is_active', true).limit(1),\n      supabase.from('savings_goals').select('id').eq('household_id', householdMember.household_id).eq('is_active', true).limit(1)\n    ]);\n    \n    return NextResponse.json({\n      budgetSetupCompleted: household.budget_setup_completed,\n      stepsCompleted: {\n        income: incomeResponse.data.length > 0,\n        expenses: expensesResponse.data.length > 0,\n        envelopes: envelopesResponse.data.length > 0,\n        savings: savingsResponse.data.length > 0\n      }\n    });\n  } catch (error) {\n    console.error('Error checking budget setup status:', error);\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n  }\n}\n```",
        "testStrategy": "1. End-to-end test the complete budget setup flow:\n   - Test navigation between all steps\n   - Verify data persistence across step navigation\n   - Test completion of the setup process\n   - Verify redirect to dashboard after completion\n2. Test progress tracking:\n   - Verify the progress indicator shows the correct step\n   - Test that completed steps are properly tracked\n   - Test resuming from the first incomplete step\n3. Test error handling:\n   - Test recovery from API failures\n   - Test handling of missing household context\n4. Test responsive layout on different screen sizes\n5. Performance testing with realistic data volumes\n6. Accessibility testing for the entire flow",
        "priority": "high",
        "dependencies": [
          1,
          2,
          5,
          8
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-20T15:12:13.375Z",
      "updated": "2025-06-20T15:49:59.933Z",
      "description": "Tasks for master context"
    }
  }
}